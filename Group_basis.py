from sage.all import *

### Discrete logarithm

def DL_exhaust(e,B,h,p,r):
	r""" 
	Computes the discrete logarithm of h in basis B in a p-group of exponent p 
	by exhaustive search.

	INPUT:

	* e: neutral element of the group

	* B: basis (list of group elements of length r)

	* h: group element

	* p: prime number

	* r: length of B

	OUTPUT:

	Returns the discrete logarithm of h in B if h is in the subgroup generated by B 
	as a list of r integers between 0 and p-1. Raises a ValueError if h is not in 
	the subgroup generated by B.
	"""
	if r==1:
		g0=B[0]
		g=e
		k=0
		while g!=h and k<p:
			g=g*g0
			k+=1
		if g==h:
			return [k%p]
		else:
			raise ValueError('Element g is not in the subgroup generated by the basis B')
	else:
		g=h
		C=B[0:r-1]
		gr=B[r-1]
		k=0
		while k<p:
			try:
				dl=DL_exhaust(e,C,g,p,r-1)
				return dl+[(p-k)%p] 
			except ValueError:
				g=gr*g
				k+=1
		raise ValueError('Element g is not in the subgroup generated by the basis B')


def DL_PH(e,B,h,p,r):
	r""" 
	Computes the discrete logarithm of h in basis B in a p-group of any exponent 
	using Pohlig-Hellman method.

	INPUT:

	* e: neutral element of the group

	* B: basis (list of group elements of length r)

	* h: group element

	* p: prime number

	* r: length of B

	OUTPUT:

	Returns the discrete logarithm of h in B if h is in the subgroup generated by B 
	as a list of r integers between 0 and p^sigma-1, where p^sigma is the exponent 
	of the group. Raises a ValueError if h is not in the subgroup generated by B.

	Note that this fuction uses DL_exhaust.
	"""

	# Computation of the logarithm of the orders in base p and the basis of exponent p
	L_sigma=[0]*r
	C=B.copy()
	for i in range(r):
		gi=B[i]
		while gi!=e:
			L_sigma[i]+=1
			C[i]=gi
			gi=gi**p
	sigma=max(L_sigma)
	
	# Sorting the basis so that the orders decrease (using naive sorting algorithm)
	B1=B.copy()
	L_perm=list(range(r))# records the permutations
	for i in range(r):
		m=L_sigma[i]
		i_max=i
		for j in range(i,r):
			if L_sigma[j]>m:
				m=L_sigma[j]
				i_max=j
		L_sigma[i],L_sigma[i_max]=L_sigma[i_max],L_sigma[i]
		B1[i],B1[i_max]=B1[i_max],B1[i]
		C[i],C[i_max]=C[i_max],C[i]
		L_perm[i],L_perm[i_max]=L_perm[i_max],L_perm[i]	

	# Computing the powers of h
	H=[h]
	for i in range(1,sigma):
		H.append(H[i-1]**p)

	# Main Polling-Hellman loop
	X=[0]*r
	ri=0# First index such that L_sigma[ri]<=i
	for i in range(sigma-1,-1,-1):
		hi=H[i]
		while ri<r and L_sigma[ri]>=i+1:
			ri+=1
		for k in range(ri):
			hi=hi*B1[k]**(-(p**i)*X[k])
		Y=DL_exhaust(e,C[0:ri],hi,p,ri)
		for j in range(ri):
			X[j]+=p**(L_sigma[j]-i-1)*Y[j]
	
	# Inverse permutation 
	X_ret=[0]*r
	for i in range(r):
		X_ret[L_perm[i]]=X[i]
	return X_ret

def DL(e,B,h,L_factors,r):
	r"""
	Computes the discrete logarithm of h in basis B. We do not assume that we
	are in a p-group here.

	INPUT:

	* e: neutral element of the group

	* B: basis (list of group elements of length r)

	* h: group element

	* L_factors: list of factors of the group order in the form (prime, exponent) 

	* r: length of B

	OUTPUT:

	Returns the discrete logarithm of h in the basis B.
	"""

	N=1
	for factor in L_factors:
		N*=factor[0]**factor[1]

	L_DL=[]
	for i in range(len(L_factors)):
		Ni=N//(L_factors[i][0]**L_factors[i][1])
		Bi=[g**Ni for g in B]
		hi=h**Ni
		L_DL.append(DL_PH(e,Bi,hi,L_factors[i][0],r))

	X_ret=[]
	moduli=[ZZ(factor[0]**factor[1]) for factor in L_factors]
	for k in range(r):
		vk=[]
		for x in L_DL:
			vk.append(x[k])
		X_ret.append(CRT_list(vk,moduli))
	return X_ret


### Basis of a group

def Basis_p(e,S,p):
	r""" 
	Computes the basis of the p-(sub)group generated by S.

	INPUT:

	* e: neutral element of the group

	* S: list of group elements

	* p: prime number

	OUTPUT:

	Returns a basis B of the p-(sub)group generated by S in decreasing order
	together with the list E_B of logarithms in base p of its orders. 
	Returns empty lists if the (sub)group generated by S is trivial.
	"""
	t=len(S)
	S1=S.copy()
	B=[]
	E_B=[]#log_p(orders) of B
	E=[0]*t#log_p(orders) of S
	for i in range(t):
		gi=S1[i]
		while gi!=e:
			E[i]+=1
			gi=gi**p
	E_max=max(E)

	# Adding first element in B
	if E_max==0:
		return B,E_B
	else:
		i0=E.index(E_max)
		B.append(S1[i0])
		E_B.append(E_max)
		del S1[i0]
		del E[i0]
		t=t-1

	# Main loop with orthogonalization process
	while t>0:
		r=len(B)
		S_update=[]
		E_update=[]
		for i in range(t):
			if E[i]>0:
				b_continue=True
				e_i=0
				C=B.copy()
				hi=S1[i]
				while b_continue and e_i<E[i]:
					ri=0
					while ri<r and E_B[ri]>=e_i+1:
						ri+=1
					try:
						Xi=DL_PH(e,C[0:ri],hi,p,ri)
						b_continue=False
					except:
						C=[c**p for c in C]
						hi=hi**p
						e_i+=1
				s=S1[i]
				if e_i<E[i]:
					for j in range(ri):
						s*=B[j]**(-Xi[j])
				S_update.append(s)
				E_update.append(e_i)
		E=E_update.copy()
		S1=S_update.copy()
		# Updating S and B as previously
		if len(E)==0:
			return B,E_B
		else:
			E_max=max(E)
			if E_max==0:
				return B,E_B
			else:
				i0=E.index(E_max)
				B.append(S1[i0])
				E_B.append(E_max)
				del S1[i0]
				del E[i0]
				t=len(S1)
	return B,E_B

def IsBasis(e,B,C,E_C,p):
	r""" 
	Tests the correctness of Basis_p. Given a known basis B of a p-group G 
	(e.g. canonical) and a basis C together with the list of logarithms 
	in base p of its orders E_C, outputted by Basis_p, tests if C is indeed 
	a basis of G.

	INPUT:

	* e: neutral element of the group

	* B: known basis

	* C: outputted basis

	* E_C: outputted list of logarithms in base p of the orders of elements of C

	* p: prime number

	OUTPUT:

	Returns True if C is a basis of G, False otherwise.
	"""
	r=len(B)
	if len(C)!=r:
		return False

	# Computing the log in base p of the orders of B and C
	L_sigma_B=[0]*r
	L_sigma_C=[0]*r
	for i in range(r):
		gi=B[i]
		while gi!=e:
			L_sigma_B[i]+=1
			gi=gi**p
	for i in range(r):
		gi=C[i]
		while gi!=e:
			L_sigma_C[i]+=1
			gi=gi**p
	# We should have L_sigma_B.sort()==L_sigma_C by unicity of the invariant factors
	L_sigma_B.sort(reverse=True)
	if L_sigma_B!=L_sigma_C or L_sigma_C!=E_C:
		return False

	# Tests if all elements of B are generated by C and conclude by cardinality
	for i in range(r):
		try:
			X=DL_PH(e,C,B[i],p,r)
		except ValueError:
			return False
	return True

def IsBasis2(e,B,C,p):
	r""" 
	Variant of IsBasis that does not check the orders. Given a known basis B 
	of a p-group G (e.g. canonical) and a basis C, tests if C is indeed 
	a basis of G.

	INPUT:

	* e: neutral element of the group

	* B: known basis

	* C: tested basis

	* p: prime number

	OUTPUT:

	Returns True if C is a basis of G, False otherwise.
	"""
	r=len(B)
	if len(C)!=r:
		return False

	# Computing the log in base p of the orders of B and C
	L_sigma_B=[0]*r
	L_sigma_C=[0]*r
	for i in range(r):
		gi=B[i]
		while gi!=e:
			L_sigma_B[i]+=1
			gi=gi**p
	for i in range(r):
		gi=C[i]
		while gi!=e:
			L_sigma_C[i]+=1
			gi=gi**p
	# We should have L_sigma_B.sort()=L_sigma_C.sort() by unicity of the invariant factors
	if L_sigma_B.sort()!=L_sigma_C.sort():
		return False

	# Tests if all elements of B are generated by C and conclude by cardinality
	for i in range(r):
		try:
			X=DL_PH(e,C,B[i],p,r)
		except ValueError:
			return False
	return True


def Basis(e,S,N,L_factors):
	r""" 
	Computes the basis of the (sub)group G generated by S adapted to its decomposition
	into p-Sylows.

	INPUT:

	* e: neutral element of the group

	* S: list of group elements

	* N: cardinality of the group G

	* L_factors: list of tuples (prime,exponent) involved in the decomposition of N

	OUTPUT:

	Returns a basis B of the (sub)group G generated by S as a concatenation of basis of 
	the p-Sylows of G for all p|N, together with the list of orders given as tuples 
	(p,e) where the exponent e is decreasing for p constant.

	This function uses Basis_p.
	"""
	s=len(L_factors)
	B=[]
	L_orders=[]
	for i in range(s):
		pi,alphai=L_factors[i]
		Ni=N//pi**alphai
		Si=[s**Ni for s in S]
		Bi,E_Bi=Basis_p(e,Si,pi)
		B+=Bi
		L_orders+=[(pi,ei) for ei in E_Bi]
	return B,L_orders


### Get relations from a basis

def DL_matrix(e,S,B,L_orders):
	r""" 
	Computes the matrix of discrete logarithms of elements of S in the basis B.

	INPUT:

	* e: neutral element of the group

	* S: list of group elements

	* B: basis

	* L_orders: list of orders of elements of B written as (prime,exponent)

	OUTPUT:

	Returns the matrix of discrete logarithms of elements of S in the basis B, where
	the column M[,j] is the discrete logarithm of S[j] for all j in range(len(S)).
	"""

	# Recomputes the list L_factors with L_orders 
	L_index_p=[0]
	p=L_orders[0][0]
	L_p=[p]
	L_alphap=[L_orders[0][1]]
	r=len(L_orders)
	for i in range(r):
		if L_orders[i][0]!=p:
			p=L_orders[i][0]
			L_index_p.append(i)
			L_p.append(p)
			L_alphap.append(L_orders[i][1])
		else:
			L_alphap[-1]+=L_orders[i][1]
	L_index_p.append(r)

	s=len(L_p)
	t=len(S)
	N=1
	M=[[] for j in range(t)]
	for i in range(s):
		N*=L_p[i]**L_alphap[i]

	# Main loop with discrete logarithm
	for i in range(s):
		Ni=N//L_p[i]**L_alphap[i]
		ri=L_index_p[i+1]-L_index_p[i]
		Bi=[B[k]**Ni for k in range(L_index_p[i],L_index_p[i+1])]
		for j in range(t):
			sij=S[j]**Ni
			M[j]+=DL_PH(e,Bi,sij,L_p[i],ri)
	return matrix(ZZ,M).transpose()


def IsGoodDL_matrix(e,B,M,S):
	r""" 
	Testing function for DL_matrix. Tests if M is the discrete logarithm matrix of S 
	in the basis B.

	INPUT:

	* e: neutral element of the group

	* B: basis

	* M: discrete logarithm matrix

	* S: list of group elements
	
	OUTPUT:

	Returns True if M has the correct size and if column M[,j] is the discrete logarithm 
	of S[j] for all j in range(len(S)), and False otherwise.
	"""

	r=len(B)
	t=len(S)
	if M.nrows()!=r or M.ncols()!=t:
		return False

	for j in range(t):
		gj=e
		for i in range(r):
			gj*=B[i]**M[i,j]
		if gj!=S[j]:
			return False
	return True


def Lattice_basis(M,b):
	r""" 
	Computes a basis of the lattice of integer vectors e such that M[i]*e = 0 mod b[i]
	for all i in range(M.nrows()).

	INPUT:

	* M: integer matrix of size r*t

	* b: list of integers of length r
	
	OUTPUT:

	Returns a matrix of integers of size t*t whose columns form a basis of the lattice. 
	"""

	r=len(b)
	t=M.ncols()
	L_A=[]
	for i in range(r):
		Ai=block_matrix(ZZ,[[matrix(M[i])],[b[i]]])
		# Here, the generator vectors are the lines and not the columns (because of HNF)
		L_A.append(Ai)
	m=lcm(b)
	A=block_matrix(ZZ,[[(m//b[i])*L_A[i]] for i in range(r)])
	A1=A.hermite_form()
	B=m*A1[0:t,0:t].inverse()
	return B.change_ring(ZZ)


def IsGoodLatticeBasis(B,M,b):
	r""" 
	Testing function for Lattice_basis. Checks if M[i]*B[j] = 0 mod b[i] for all i in 
	range(r) and j in range(t).

	INPUT:

	* B: basis matrix of size t*t

	* M: integer matrix of size r*t

	* b: list of integers of length r
	
	OUTPUT:
	
	Returns True if if M[i]*B[j] = 0 mod b[i] for all i in range(r) and j in range(t), 
	False otherwise.
	"""

	r=len(b)
	t=M.ncols()
	m=1
	for i in range(r):
		m*=b[i]
	if m!=B.det():
		return False
	C=M*B
	for i in range(r):
		for j in range(t):
			if C[i,j]%b[i]!=0:
				return False
	return True

