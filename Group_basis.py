### Discrete logarithm

## Echaustive search discrete logarithm in a p-group of exponent p
# Note that the result is in interval [0,p-1]**r
def DL_exhaust(e,B,h,p,r):
	if r==1:
		g0=B[0]
		g=e
		k=0
		while g!=h and k<p:
			g=g*g0
			k+=1
		if g==h:
			return [k%p]
		else:
			raise ValueError('Element g is not in the subgroup generated by the basis B')
	else:
		g=h
		C=B[0:r-1]
		gr=B[r-1]
		k=0
		while k<p:
			try:
				dl=DL_exhaust(e,C,g,p,r-1)
				return dl+[(p-k)%p] 
			except ValueError:
				g=gr*g
				k+=1
		raise ValueError('Element g is not in the subgroup generated by the basis B')


## Pohlig-Hellman in a p-group
def DL_PH(e,B,h,p,r):
	# Computation of the logarithm of the orders in base p and the basis of exponent p
	L_sigma=[0]*r
	C=B.copy()
	for i in range(r):
		gi=B[i]
		while gi!=e:
			L_sigma[i]+=1
			C[i]=gi
			gi=gi**p
	sigma=max(L_sigma)
	
	# Sorting the basis so that the orders decrease (using naive sorting algorithm)
	B1=B.copy()
	L_perm=list(range(r))# records the permutations
	for i in range(r):
		m=L_sigma[i]
		i_max=i
		for j in range(i,r):
			if L_sigma[j]>m:
				m=L_sigma[j]
				i_max=j
		L_sigma[i],L_sigma[i_max]=L_sigma[i_max],L_sigma[i]
		B1[i],B1[i_max]=B1[i_max],B1[i]
		C[i],C[i_max]=C[i_max],C[i]
		L_perm[i],L_perm[i_max]=L_perm[i_max],L_perm[i]	

	# Computing the powers of h
	H=[h]
	for i in range(1,sigma):
		H.append(H[i-1]**p)

	# Main Polling-Hellman loop
	X=[0]*r
	ri=0# Firts index such that L_sigma[ri]<=i
	for i in range(sigma-1,-1,-1):
		hi=H[i]
		while ri<r and L_sigma[ri]>=i+1:
			ri+=1
		for k in range(ri):
			hi=hi*B1[k]**(-(p**i)*X[k])
		Y=DL_exhaust(e,C[0:ri],hi,p,ri)
		for j in range(ri):
			X[j]+=p**(L_sigma[j]-i-1)*Y[j]
	
	# Inverse permutation 
	X_ret=[0]*r
	for i in range(r):
		X_ret[L_perm[i]]=X[i]
	return X_ret

